BY Mr-Wu Note
2018.12.04:
1.成功  ：一个8266作为客户端给一个8266服务器发信息
  未实现：服务端和客户端互相通信
  下一步：将8266都连上路由器，根据每个的IP针对性发信息
2018.12.06：
发现以8266做服务端和客户端时，其服务端最大接入数量为5，因此放弃此套方案。
还有两种方案：
1.采用8266为客户端（节点），Openwrt路由器为服务端（主机）
优点：对网络知识可以较全面的掌握，为之后项目作技术储备。
缺点：需自己写Socket，工程量大，技术难度大，实现时间久。
2.采用Zigbee组网方式
优点：工作量小，能够快速实现组网通信功能
缺点：对内部技术体系不了解，如果遇到问题难解决。
2018.12.07：
经思考和讨论决定采用Zigbee组网方式，快速将平台搭建起来，以实现该需要的功能，实现之后再研究Socket方案。
买了4个以蓝牙4.0 mesh协议的Zigbee模块，准备实验。
2018.12.13
将收发串口改为串口2后Zigbee模块测试正常，互相收发数据正常，基本通信平台已搭建成功。
2018.12.14
重温了ucos，高级指针
2018.12.15
2018.12.16、2018.12.17
完成：1.主机每次接收到送餐区AGV发来的位置信号后与其前方的车的坐标作比较，并迅速发回是否安全信号。
2.客户端从厨师位出发后每隔0.5秒向主机发送位置信号，并且必须得到主机的回应，告知是否安全。利用定时器解决了“如果N秒内没有得到主机的回应则自动停车”的问题。
2018.12.18
打通了主机端串口1与串口2之间的通信逻辑
在主程序main函数添加了“触摸屏确认发送桌号信息”和“验证第一辆待出发AGV已离开”
2018.12.19
第一辆AGV出发后至少1秒第二辆AGV才可出发的解决方案是：第一辆出发AGV发送指定RFID信息表示已到达某点 后车可安全出发（若采用此方式则昨天的It_is_go_Flag可废除）
假设发送指定RFID数据信息为0xDD,0xDD。
2018.12.20
画出整个系统思维导图；将梓聪 超声波程序 整合进 客户端AGV程序内。
2018.12.21
根据昨天画的思维导图，目前还缺：主机端发给客户端目标桌号填充数组内，并且可根据这一变量在其前面刹车（小算法）
缺：顾客拿走餐品后，没有给AGV赋厨师位值以告诉AGV该回厨师位了
做了如下规定：
1.在客户端main函数里客户端给主机回应“我已出发(I_am_go_Flag)”，数据格式为（0xAA,0xFB,0x00,0x20,0x21,0x11,0x11）,第五位表示是几号客户端发给主机，0x11为已出发Flag。
2.在客户端串口1中断服务函数里，当AGV到达接餐口读取到0xdd的RFID信息后给主机发送位置(Arrival_Where)，数据格式为（0xAA,0xFB,0x00,0x20,0x21,0x,0x）,0xdd为接餐口RFID值。
3.在客户端串口1中断服务函数里，RFID_Data[]用于存放读取到的RFID值，RFID_Data[3],RFID_Data[4]用于存RFID坐标信息。
4.在服务端串口2中断服务函数里，主机给AGV回应是否安全的信号时，数据格式为（0xAA,0xFB,0x00,0x21,0x13,0x13）(0x14,0x14)为不安全。
5.在服务端main函数里主机向客户端发送目标桌号信息，数据格式为（0xAA,0xFB,0x00,0x21,0xdd,0x,0x），0xdd为标志号，第六位为RFID号，第七位为座位号(语音播报用)。
2018.12.22
测试Zigbee远距离通信，测试Zigbee分身转发数据扩大通信距离，结果正常。
2019.01.07
回顾之前的工程，整理还未写出的功能。
1.在客户端main函数里还缺“&&上服务端已发出指令”	 已改
2.在客户端串口2中缺 接收到主机

疑问解答：
一、如果是组网通过广播形式进行传输信号的话，第一辆待出发小车如何分辨当前位置并拒绝接收来自其它小车的信息只接收厨师端服务器的信息？
答：通过RFID信号，当小车接收到这个RFID信号时，则只接收厨师端服务器的信号。（如果RFID感应距离太远则采用金属触点方式）（如果RFID感应距离太远也可采用送餐任务标志位解决）。
整个餐厅分为两大块区域，一个是送餐区域一个是接餐区域，两个区域除了小车出发时对送餐区域小车广播出发信号，其它时间互不通信。（如果跑道是单轨，则无需广播，只需对前一辆小车发出信号，等待前一辆小车的应答是否待会需要停车）
二、组网的方式，内部如何处理信号？
答：两种解决方案：
1、采用广播组网方式，所有信号均以广播的形式发出去，在跑道上的AGV接收，并回传应答信号，发信号端如果在一段时间内（延时？）检测是否有应答信号没有接收到，若有则单独向其发送信号等待应答。
2、采用点对点的方式，停下来的车向送餐区域的车分别发信号并等待应答之后再向其它车发信号。（缺点：如果其中一台车突然坏了，则其它车将一直都不到信号）
三、


一、
1.从厨师位出发时对送餐区AGV广播发出出发信号，送餐区AGV接收到出发信号后回应当前位置。（缺点：如果最后一台车漏回应了）
2.AGV到达目标位置广播停下坐标信息，后面AGV自动接收自行判断该停下的位置


二、
客户端：
1.从厨师位出发后每隔0.5秒向主机发送位置信号，并且必须得到主机的回应，告知是否安全。
2.如果N秒内没有得到主机的回应，则(1)马上停车发出警报。(2)与其它在送餐区的AGV小车通信，完成配送。(3)马上停车发出警报，并等店员确认完成最后一次配送后与其它在送餐区的AGV小车通信，完成配送。
3.当一台正在配送的AGV出现了故障或者停车或者关机，主机自动将其之后的车与出现故障AGV最后一次位置做比较，并且发出警报。
程序逻辑：
任务1. 定时器每隔0.5秒产生中断，发送当前位置信号。等待回应，超时则停车警报。
任务2. 

主机端：
1.每次接收到送餐区AGV发来的位置信号后与其前方的车的坐标作比较，并迅速发回是否安全信号。
2.当厨师输入餐桌号要求送餐时，AGV自动保持与上一台AGV出发间隔至少一秒的等待时间再出发（保证安全距离）
程序逻辑：
任务1. 接收厨师发送的送餐信号，等待与上一台AGV发出时间间隔至少一秒后再发出。
(1)有可能需要RTC记录时间;
(2)不用RTC可能会产生冲突，例如如果间隔一秒的解决方案是在串口中断服务函数里面delay_ms(1000)，则意味着这1秒内主机干不了其它事情；如果采用定时器的方式，比较复杂；
(3)触控屏端处理；
任务2. 实时接收送餐区各AGV小车传来的位置信号，并将其实时存储，再与前车位置作比较，再回应是否安全的信号。

主机端串口：
接收送餐AGV传来位置信息并回应
接收厨师端主机发出目标位置并出发：串口接收一段数据，选取第四个为目标数据，将其赋值给Table_Numble桌号标志位；串口二实时检测Table_Numble的值，当其不为0时将数据发送给第一辆待出发AGV（检测第一辆待出发AGV是哪一台的方式：1.通过传感器检测；2.不检测，直接广播然后利用&运算将数据发至目标AGV）；3.通过AGV到达的RFID信息先给主机一个信号，再判断此AGV为第一辆待出发AGV|||客户端主程序不断检测桌号标志位，再出发，当客户端AGV检测到目标RFID值，将桌号标志位清零。

串口2：
接收送餐AGV传来位置信息并判断是否安全再回应；
当有AGV已就绪接餐时，接收AGV到达接餐窗口信号和检测(Master_Send_Flag=1)并回应，AGV_Here_Flag标志位 置1(串口1用)；

串口1：
当AGV_Here_Flag=1时接收触摸屏的桌号命令，桌号信息保存在Table_Numble中，Master_Send_Flag标志位 置1。


客户端串口：
当送餐AGV到达接餐窗口，为第一辆待出发AGV，此时一旦检测到接餐窗口RFID信息则自动发送当前位置并关掉每隔0.5s发送一次定时器使能；
接收来自主机的到达回应和等待接收来自主机的桌号命令，若接到来自主机的桌号命令则回应I_am_go_Flag标志位给主机告知已离开；
重置定时器值，打开定时器使能。

发送位置信息给主机并回收回应
控制超声波进行传输数据
RFID数据传输


























fac_us=SystemCoreClock/8000000;	为系统时钟的1/8.
fac_ms=fac_us*1000；
SysTick->LOAD=nus*fac_us; 时间加载 		 
SysTick->VAL=0x00;清空计数器
SysTick->CTRL|=SysTick_CTRL_ENABLE_Msk ;开始倒数
temp=SysTick->CTRL;取时间还剩多少
if(!(temp&0x01&&!(temp&(1<<16))))时间到达